<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TinyMSG | Unified Resonance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&family=Outfit:wght@900&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/phosphor-icons/1.4.1/duotone/style.min.css">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <style>
        /* VERSION 30.64: TinyMSG SUPER-MAGNIFIED EDITION (2X TEXT & INPUT) */
        :root {
            --primary-blue: #0052ff;
        }

        html, body { 
            height: 100dvh; 
            margin: 0; padding: 0; 
            overflow: hidden;
            background: #f8fafc;
            font-family: 'Plus Jakarta Sans', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .chat-container-snapped { 
            width: 95%; 
            max-width: 900px; 
            height: calc(100dvh - 30px); 
            background: white; 
            border-radius: 4rem; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            box-shadow: 0 40px 100px -20px rgba(0,0,0,0.15);
            border: 1px solid #f1f5f9;
            margin: auto;
            position: relative;
        }

        .logo-mark {
            @apply w-12 h-12 md:w-16 md:h-16 bg-[#0052ff] rounded-[1.5rem] flex items-center justify-center text-white font-black text-2xl md:text-3xl shadow-lg shadow-blue-200 rotate-[-10deg];
        }

        .header-title-v34 {
            font-family: 'Outfit', sans-serif;
            @apply text-3xl md:text-5xl font-black tracking-tighter text-slate-900 uppercase italic leading-none;
        }

        .chat-header-prototype {
            padding: 2.5rem;
            @apply md:p-14 md:pb-10;
            background: white;
            border-bottom: 1px solid #f1f5f9;
        }

        .chat-messages-prototype { 
            flex: 1; 
            overflow-y: auto; 
            padding: 2.5rem;
            @apply md:p-14;
            display: flex; 
            flex-direction: column; 
            gap: 2.5rem; /* Doubled Gap */
            background: white;
            font-family: 'Inter', sans-serif;
            -webkit-overflow-scrolling: touch;
        }

        .bubble-apple { 
            max-width: 85%; 
            padding: 1.5rem 2rem;
            @apply md:p-10;
            border-radius: 2.5rem; 
            font-size: 1.25rem; /* ~2X Mobile */
            @apply md:text-3xl; /* ~2X Desktop */
            font-weight: 600; 
            line-height: 1.3;
            position: relative; 
        }

        .bubble-me { 
            align-self: flex-end; 
            background: var(--primary-blue); 
            color: white; 
            border-bottom-right-radius: 0.5rem;
            box-shadow: 0 12px 30px -10px rgba(0,82,255,0.4);
        }

        .bubble-them { 
            align-self: flex-start; 
            background: #f1f5f9; 
            color: #0f172a; 
            border-bottom-left-radius: 0.5rem;
        }

        .input-area-prototype { 
            padding: 2rem 2rem 3rem 2rem;
            @apply md:p-14 md:pt-4;
            background: white; 
        }

        .command-center-telegram { 
            background: white; 
            border-radius: 3rem; 
            padding: 0.75rem;
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            border: 2px solid #f8fafc;
            margin-left: 0;
            margin-right: 0;
        }

        /* Telegram-style input */
        .field-telegram { 
            flex: 1; 
            background: transparent; 
            border: none; 
            padding: 0.75rem 1rem; 
            font-size: 1.125rem;
            @apply md:text-2xl;
            font-weight: 500;
            outline: none; 
            color: #0f172a;
            width: 90%; /* 10% shorter */
            margin-left: 0.5rem;
        }

        .action-icon-prototype { 
            @apply w-12 h-12 md:w-20 md:h-20 rounded-full;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.06);
            color: #64748b;
            cursor: pointer;
            font-size: 1.5rem;
            @apply md:text-3xl;
        }

        .emoji-bar-prototype {
            display: flex;
            gap: 1.5rem;
            overflow-x: auto;
            padding: 2rem 2.5rem;
            @apply md:px-14;
        }
        .emoji-item { font-size: 3rem; @apply md:text-6xl; cursor: pointer; transition: transform 0.2s; }

        .btn-close-v34 {
            @apply w-16 h-16 md:w-28 md:h-28 rounded-full bg-slate-100 flex items-center justify-center text-slate-400 hover:text-black transition-all text-4xl md:text-6xl;
            margin-right: 2rem;
            transform: translateX(-50%);
        }

        .orange-arrow-btn {
            @apply w-12 h-12 md:w-16 md:h-16 rounded-full bg-[#f97316] flex items-center justify-center text-white cursor-pointer hover:bg-[#fb923c] active:scale-90 transition-transform;
            margin-left: 0.5rem;
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.3);
            position: relative;
            z-index: 10;
        }

        ::-webkit-scrollbar { width: 0; background: transparent; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        // FILE VERSION: V30.64
        const { useState, useEffect, useRef, createElement: h, useCallback } = React;
        const SUPABASE_URL = 'https://cijsxlylkanxmzkteabg.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_cOcjpEDxsX7EH-5cm0ByxA_OqbizsX4';
        const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // Debounce utility function - defined once outside the component
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        function ChatApp() {
            const [session, setSession] = useState(null);
            const [target, setTarget] = useState({id: null, username: ''});
            const [messages, setMessages] = useState([]);
            const [msg, setMsg] = useState(''); // Text for the actual message input
            const [recentUsers, setRecentUsers] = useState([]);
            const scrollRef = useRef();

            // Autocomplete states for the @soul input
            const [suggestions, setSuggestions] = useState([]);
            const [atInput, setAtInput] = useState(''); // Text for the @soul search input

            const EMOJIS = ['ðŸ•Šï¸', 'âœ¨', 'ðŸ§¡', 'ðŸŒ±', 'ðŸ§ ', 'â›µ', 'ðŸŒ‘', 'ðŸ’Ž', 'ðŸ•¯ï¸', 'ðŸ§¿', 'ðŸŒŠ', 'ðŸ”¥', 'ðŸŒ€', 'ðŸ§¬', 'ðŸ¹'];

            useEffect(() => {
                client.auth.getSession().then(({ data }) => setSession(data.session));
                client.auth.onAuthStateChange((_, s) => setSession(s));
            }, []);

            const fetchRecent = async (userId) => {
                if (!userId) return;
                // Fetch recent unique chat partners from both sent and received messages
                const { data: sentMessages } = await client
                    .from('messages')
                    .select('receiver_id, receiver:receiver_id(username)')
                    .eq('sender_id', userId)
                    .order('created_at', { ascending: false });
                
                const { data: receivedMessages } = await client
                    .from('messages')
                    .select('sender_id, sender:sender_id(username)')
                    .eq('receiver_id', userId)
                    .order('created_at', { ascending: false });

                const allRelatedMessages = [...(sentMessages || []), ...(receivedMessages || [])];
                const uMap = new Map();
                allRelatedMessages.forEach(m => {
                    const other = m.receiver || m.sender;
                     // Ensure the 'other' user object has a username and its ID is not the current user's ID
                    if (other && other.username && other.id !== userId && !uMap.has(other.username)) {
                        uMap.set(other.username, other);
                    }
                });
                setRecentUsers(Array.from(uMap.values()).slice(0, 5)); // Limit to 5 recent users
            };

            const fetchMsg = async () => {
                if (!target.id || !session) return;
                // Fetch messages for the current target and logged-in user
                const { data } = await client.from('messages').select('*').or(`and(sender_id.eq.${session.user.id},receiver_id.eq.${target.id}),and(sender_id.eq.${target.id},receiver_id.eq.${session.user.id})`).order('created_at', { ascending: true });
                setMessages(data || []);
            };

            useEffect(() => {
                if (session) fetchRecent(session.user.id);
            }, [session]);

            useEffect(() => {
                if (target.id) {
                    fetchMsg();

                    const msgSubscription = client.channel(`chat_messages`)
                        .on('postgres_changes', { 
                            event: 'INSERT', 
                            schema: 'public', 
                            table: 'messages', 
                            filter: `(sender_id=eq.${target.id}.or.receiver_id=eq.${target.id})` // Filter for messages involving the target
                        }, (payload) => {
                            // Only refetch if the new message is between current user and current target
                            const isFromCurrentUser = payload.new.sender_id === session.user.id;
                            const isToCurrentUser = payload.new.receiver_id === session.user.id;
                            const isFromTarget = payload.new.sender_id === target.id;
                            const isToTarget = payload.new.receiver_id === target.id;

                            if ((isFromCurrentUser && isToTarget) || (isFromTarget && isToCurrentUser)) {
                                fetchMsg();
                            }
                        })
                        .subscribe();

                    return () => client.removeChannel(msgSubscription);
                } else {
                    // If target is cleared, clear messages
                    setMessages([]); 
                }
            }, [target.id, session]); // Dependencies for this effect

            useEffect(() => {
                if (scrollRef.current) {
                    scrollRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
            }, [messages]);

            // Debounced function for fetching user suggestions (memoized)
            const debouncedFetchSuggestions = useCallback(
                debounce(async (query) => {
                    if (!session) {
                        setSuggestions([]);
                        return;
                    }
                    
                    let users = [];
                    // If query is empty or just '@', fetch all users, otherwise filter
                    if (query === '' || query === '@') {
                        const { data, error } = await client
                            .from('profiles')
                            .select('id, username')
                            .not('id', 'eq', session.user.id) // Don't suggest self
                            .order('username', { ascending: true })
                            .limit(10); // Limit total suggestions
                        users = data || [];
                    } else { // Otherwise, filter by query
                        const { data, error } = await client
                            .from('profiles')
                            .select('id, username')
                            .ilike('username', `${query}%`) // Search usernames starting with query (case-insensitive)
                            .not('id', 'eq', session.user.id) // Don't suggest self
                            .order('username', { ascending: true })
                            .limit(10); // Limit total suggestions
                        users = data || [];
                    }

                    // Exclude current target from suggestions if a target is actively selected
                    setSuggestions(users.filter(u => u.username !== target.username.substring(1))); 
                }, 300), // 300ms debounce delay
                [session, target] // Recreate if session or target changes
            );

            const handleAtInputChange = e => {
                const value = e.target.value;
                setAtInput(value); // Keep input field controlled
                if (value.startsWith('@')) {
                    debouncedFetchSuggestions(value.substring(1)); // Pass query without '@'
                } else {
                    setSuggestions([]); // Clear suggestions if no @ is typed or @ is removed
                }
            };

            const selectSuggestedUser = (user) => {
                setTarget({ id: user.id, username: `@${user.username}` });
                setAtInput(`@${user.username}`); // Populate the @soul input with selected handle
                setSuggestions([]); // Clear suggestions
                setMsg(''); // Clear message input (if any previous text) 
            };

            const linkUser = async (userObj) => {
                let id, username;
                if (typeof userObj === 'string') {
                    const cleanName = (userObj || "").replace(/@/g,'').toLowerCase().trim();
                    const { data } = await client.from('profiles').select('id, username').eq('username', cleanName).maybeSingle();
                    if (!data) return; // User not found
                    id = data.id;
                    username = `@${data.username}`;
                } else { // If userObj is already {id, username} from recentUsers
                    id = userObj.id;
                    username = `@${userObj.username}`;
                }
                setTarget({id: id, username: username});
                setAtInput(username); // Populate the input field
                setSuggestions([]); // Clear suggestions
            };

            const sendMsg = async () => {
                // Ensure there's a message, a session, and a target selected
                if (!msg.trim() || !session || !target.id) return; 

                const contentToSend = msg; 
                setMsg(''); // Clear input immediately for better UX
                
                await client.from('messages').insert([{ sender_id: session.user.id, receiver_id: target.id, content: contentToSend }]);
            };
            
            // UI rendering logic
            if (!session) return h('div', {className: 'flex h-screen items-center justify-center font-black uppercase tracking-widest bg-white text-4xl'}, 'Loading Sync...');

            const REDIRECT_URL = window.location.origin + '/'; // Local redirection

            return h('div', { className: "chat-container-snapped animate__animated animate__zoomIn is-ready" },
                // Close button (always visible in top right)
                h('button', { onClick: () => window.location.href = REDIRECT_URL, className: "absolute top-5 right-5 z-20 w-10 h-10 rounded-full bg-slate-100 flex items-center justify-center text-slate-400 hover:text-black transition-all text-xl" }, h('i', {className: 'ph-bold ph-x'})),

                h('header', { className: "chat-header-prototype relative flex flex-col" }, 
                    h('div', { className: "flex justify-between items-center" },
                        h('div', { className: "flex items-center gap-5 md:gap-8" },
                            h('div', { className: "logo-mark" }, "i"),
                            h('div', null,
                                h('h3', { className: "header-title-v34" }, "TinyMSG"),
                                h('p', { className: "text-lg font-black text-[#0052ff] uppercase tracking-[0.2em] mt-2" }, 
                                    target.id ? target.username : "Protocol Active V30.64")
                            )
                        ),
                    ),

                    // Recent Users (Hot Buttons) - Always visible
                    recentUsers.length > 0 && h('div', { className: "flex gap-4 mt-8 pb-4 overflow-x-auto no-scrollbar" }, 
                        recentUsers.map(u => h('button', { 
                            key: u.username, 
                            onClick: () => linkUser(u), // Pass user object
                            className: `whitespace-nowrap px-8 py-3 rounded-full border-2 border-slate-100 bg-white text-lg font-black ${target.id === u.id ? 'text-white bg-[#0052ff]' : 'text-slate-400 hover:text-[#0052ff]'} transition-colors` 
                        }, `@${u.username}`)))
                    ,
                    
                    // @soul input and suggestions
                    h('div', {className: "relative mt-4"}, 
                        h('input', {
                            className: "bg-slate-50 border-2 border-slate-100 rounded-full px-8 py-3 text-xl font-bold outline-none focus:ring-4 ring-blue-100 w-full",
                            placeholder: target.id ? `Chatting with ${target.username}` : "@soul to connect",
                            value: atInput,
                            onChange: handleAtInputChange,
                            onFocus: () => { if (atInput === '') debouncedFetchSuggestions('@'); }, // Show all users on focus if empty
                            onKeyDown: e => {
                                if (e.key === 'Enter') {
                                    linkUser(atInput); 
                                    e.preventDefault(); 
                                }
                            },
                            autoFocus: !target.id 
                        }),
                        suggestions.length > 0 && h('div', { className: "absolute z-10 w-full bg-white border border-slate-200 rounded-lg shadow-lg mt-2 py-1 max-h-48 overflow-y-auto" },
                            suggestions.map(s => h('button', {
                                key: s.id,
                                onClick: () => selectSuggestedUser(s),
                                className: "block w-full text-left px-4 py-2 text-lg font-medium text-slate-700 hover:bg-slate-100 hover:text-blue-500 cursor-pointer"
                            }, `@${s.username}`)))
                    )
                ),

                h('div', { className: "chat-messages-prototype no-scrollbar" },
                    messages.length === 0 && h('div', {className: 'flex-1 flex flex-col items-center justify-center text-slate-100'}, 
                        h('i', {className: 'ph-duotone ph-broadcast text-[150px] mb-10'}), 
                        h('p', {className: 'font-black uppercase tracking-[0.4em] text-2xl'}, target.id ? `Say hello to ${target.username}` : `Awaiting Transmission`)),
                    messages.map(m => h('div', { key: m.id, className: `bubble-apple ${m.sender_id === session.user.id ? 'bubble-me' : 'bubble-them'}` }, m.content)),
                    h('div', { ref: scrollRef })
                ),

                h('div', { className: "emoji-bar-prototype no-scrollbar" },
                    EMOJIS.map(e => h('span', { key: e, onClick: () => setMsg(p => p + e), className: "emoji-item" }, e))
                ),

                h('div', { className: "input-area-prototype px-8 py-4" },
                    h('div', { className: "command-center-telegram shadow-lg flex items-center bg-white border border-orange-100" },
                        h('input', {
                            className: "field-telegram placeholder:text-slate-400",
                            placeholder: target.id ? `Message ${target.username}...` : "Select a soul to message...",
                            value: msg,
                            onChange: e => setMsg(e.target.value),
                            onKeyDown: e => e.key === 'Enter' && sendMsg()
                        }),
                        h('button', { onClick: sendMsg, className: "orange-arrow-btn" }, h('i', {className: 'ph-bold ph-arrow-up text-lg md:text-2xl'}))
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(h(ChatApp));
    </script>
</body>
</html>